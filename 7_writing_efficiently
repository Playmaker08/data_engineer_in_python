// Non-Pythonic and Pythonic ways of looping over a list
# Print the list created using the Non-Pythonic approach
i = 0
new_list= []
while i < len(names):
    if len(names[i]) >= 6:
        new_list.append(names[i])
    i += 1
print(new_list)

# Print the list created by looping over the contents of names
better_list = []
for name in names:
    if len(name) >= 6:
        better_list.append(name)
print(better_list)

# Print the list created by using list comprehension
best_list = [name for name in names if len(name) >= 6]
print(best_list)

// Built-in practice: range()
# Create a range object that goes from 0 to 5
nums = range(6)
print(type(nums))

# Convert nums to a list
nums_list = list(nums)
print(nums_list)

# Create a new list of odd numbers from 1 to 11 by unpacking a range object
nums_list2 = [*range(1,12,2)]
print(nums_list2)

// Built-in practice: enumerate()
# Rewrite the for loop to use enumerate
indexed_names = []
for i,name in enumerate(names):
    index_name = (i,name)
    indexed_names.append(index_name) 
print(indexed_names)

# Rewrite the above for loop using list comprehension
indexed_names_comp = [(i,name) for i,name in enumerate(names)]
print(indexed_names_comp)

# Unpack an enumerate object with a starting index of one
indexed_names_unpack = [*enumerate(names, 1)]
print(indexed_names_unpack)
==> Output: <script.py> output:
    [(0, 'Jerry'), (1, 'Kramer'), (2, 'Elaine'), (3, 'George'), (4, 'Newman')]
    [(0, 'Jerry'), (1, 'Kramer'), (2, 'Elaine'), (3, 'George'), (4, 'Newman')]
    [(1, 'Jerry'), (2, 'Kramer'), (3, 'Elaine'), (4, 'George'), (5, 'Newman')]

// Built-in practice: map()
# Use map to apply str.upper to each element in names
names_map  = map(str.upper, names)

# Print the type of the names_map
print(type(names_map))

# Unpack names_map into a list
names_uppercase = [*names_map]

# Print the list created above
print(names_uppercase)
=> Output: <script.py> output:
    <class 'map'>
    ['JERRY', 'KRAMER', 'ELAINE', 'GEORGE', 'NEWMAN']

// Practice with NumPy arrays
[[ 1  2  3  4  5]
 [ 6  7  8  9 10]]

# Print second row of nums
print(nums[1,:])

# Print all elements of nums that are greater than six
print(nums[nums > 6])

# Double every element of nums
nums_dbl = nums * 2
print(nums_dbl)

# Replace the third column of nums
nums[:,2] = nums[:,2] + 1
print(nums)
=> Output: <script.py> output:
    [ 6  7  8  9 10]
    [ 7  8  9 10]
    [[ 2  4  6  8 10]
     [12 14 16 18 20]]
    [[ 1  2  4  4  5]
     [ 6  7  9  9 10]]

// Bringing it all together: Festivus!
# Create a list of arrival times
arrival_times = [*range(10,60,10)]

# Convert arrival_times to an array and update the times
arrival_times_np = np.array(arrival_times)
new_times = arrival_times_np - 3

# Use list comprehension and enumerate to pair guests to new times
guest_arrivals = [(names[i],time) for i,time in enumerate(new_times)]

# Map the welcome_guest function to each (guest,time) pair
welcome_map = map(welcome_guest, guest_arrivals)

guest_welcomes = [*welcome_map]
print(*guest_welcomes, sep='\n')
=> Output: <script.py> output:
    Welcome to Festivus Jerry... You're 7 min late.
    Welcome to Festivus Kramer... You're 17 min late.
    Welcome to Festivus Elaine... You're 27 min late.
    Welcome to Festivus George... You're 37 min late.
    Welcome to Festivus Newman... You're 47 min late.

(Runtime) Time our code to: pick optimal coding approach (fastest codes means most efficient)
Calculate runtime: %timeit (magic command)
Output: Time Mean & SD (including multiple loops and runs generated)
Specifying number of runs/loops: -r2 (two runs) or -n10 (ten loops)
For multiple magic code, use %%timeit
Save into variable: use %timeit -o
(%lprun) Code profiling: Line-by-line analysis of detailed stats on frequency and duration of function calls
Profiling a function allows you to dig deeper into the function's source code and potentially spot bottlenecks. When you see certain lines of code taking up the majority of the function's runtime, it is an indication that you may want to deploy a different, more efficient technique.
(%mprun) Code profiling for memory usage: Line-by-line analysis of memory consumption

// Using %timeit
# Using list comprehension
%timeit [num for num in range(51)]

# Using unpacking of range
%timeit [*range(51)] 
=> Output: (unpacking seems slightly faster)
2.58 us +- 117 ns per loop (mean +- std. dev. of 7 runs, 100000 loops each)
1.02 us +- 22.1 ns per loop (mean +- std. dev. of 7 runs, 1000000 loops each)

// Bringing it all together: Star Wars profiling
# Use get_publisher_heroes() to gather Star Wars heroes
star_wars_heroes = get_publisher_heroes(heroes, publishers, 'George Lucas')

print(star_wars_heroes)
print(type(star_wars_heroes))

# Use get_publisher_heroes_np() to gather Star Wars heroes
star_wars_heroes_np = get_publisher_heroes_np(heroes, publishers, 'George Lucas')

print(star_wars_heroes_np)
print(type(star_wars_heroes_np))
=> Output: <script.py> output:
    ['Darth Vader', 'Han Solo', 'Luke Skywalker', 'Yoda']
    <class 'list'>
    ['Darth Vader' 'Han Solo' 'Luke Skywalker' 'Yoda']
    <class 'numpy.ndarray'>
While get_publisher_heroes_np() has faster runtime, both has the same memory consumption => get_publisher_heroes_np() is preferred

Itertools module
- Infinite iterators: count, cycle, repeat
- Finite iterators: accumulate, chain, zip_longest, etc
- Combination generators: product, permutations, combinations

// Combining Pokémon names and types
# Combine names and primary_types
names_type1 = [*zip(names, primary_types)]
print(*names_type1[:5], sep='\n')

# Combine all three lists together
names_types = [*zip(names, primary_types, secondary_types)]
print(*names_types[:5], sep='\n')

# Combine five items from names and three items from primary_types
differing_lengths = [*zip(names[:5], primary_types[:3])]
print(*differing_lengths, sep='\n')
=> Output: <script.py> output:
    ('Abomasnow', 'Grass', 'Ice')
    ('Abra', 'Psychic', nan)
    ('Absol', 'Dark', nan)
    ('Accelgor', 'Bug', nan)
    ('Aerodactyl', 'Rock', 'Flying')

The first five items in the names list are: ['Abomasnow', 'Abra', 'Absol', 'Accelgor', 'Aerodactyl']

The first five items in the primary_types list are: ['Grass', 'Psychic', 'Dark', 'Bug', 'Rock']

The first five items in the secondary_types list are: ['Ice', nan, nan, nan, 'Flying']

<script.py> output:
    ('Abomasnow', 'Grass')
    ('Abra', 'Psychic')
    ('Absol', 'Dark')

// Counting Pokémon from a sample
# Collect the count of primary types
type_count = Counter(primary_types)
print(type_count, '\n')

# Collect the count of generations
gen_count = Counter(generations)
print(gen_count, '\n')

# Use list comprehension to get each Pokémon's starting letter
starting_letters = [name[0] for name in names]

# Collect the count of Pokémon for each starting_letter
starting_letters_count = Counter(starting_letters)
print(starting_letters_count)
=> Output: <script.py> output:
    Counter({'Water': 66, 'Normal': 64, 'Bug': 51, 'Grass': 47, 'Psychic': 31, 'Rock': 29, 'Fire': 27, 'Electric': 25, 'Ground': 23, 'Fighting': 23, 'Poison': 22, 'Steel': 18, 'Ice': 16, 'Fairy': 16, 'Dragon': 16, 'Ghost': 13, 'Dark': 13}) 
    
    Counter({5: 122, 3: 103, 1: 99, 4: 78, 2: 51, 6: 47}) 
    
    Counter({'S': 83, 'C': 46, 'D': 33, 'M': 32, 'L': 29, 'G': 29, 'B': 28, 'P': 23, 'A': 22, 'K': 20, 'E': 19, 'W': 19, 'T': 19, 'F': 18, 'H': 15, 'R': 14, 'N': 13, 'V': 10, 'Z': 8, 'J': 7, 'I': 4, 'O': 3, 'Y': 3, 'U': 2, 'X': 1})

// Combinations of Pokémon
# Import combinations from itertools
from itertools import combinations

# Create a combination object with pairs of Pokémon
combos_obj = combinations(pokemon, 2)
print(type(combos_obj), '\n')

# Convert combos_obj to a list by unpacking
combos_2 = [*combos_obj]
print(combos_2, '\n')

# Collect all possible combinations of 4 Pokémon directly into a list
combos_4 = [*combinations(pokemon, 4)]
print(combos_4)
=> Output: ['Geodude', 'Cubone', 'Lickitung', 'Persian', 'Diglett']

<script.py> output:
    <class 'itertools.combinations'> 
    
    [('Geodude', 'Cubone'), ('Geodude', 'Lickitung'), ('Geodude', 'Persian'), ('Geodude', 'Diglett'), ('Cubone', 'Lickitung'), ('Cubone', 'Persian'), ('Cubone', 'Diglett'), ('Lickitung', 'Persian'), ('Lickitung', 'Diglett'), ('Persian', 'Diglett')] 
    
    [('Geodude', 'Cubone', 'Lickitung', 'Persian'), ('Geodude', 'Cubone', 'Lickitung', 'Diglett'), ('Geodude', 'Cubone', 'Persian', 'Diglett'), ('Geodude', 'Lickitung', 'Persian', 'Diglett'), ('Cubone', 'Lickitung', 'Persian', 'Diglett')]

//
